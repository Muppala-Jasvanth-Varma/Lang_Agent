from typing import List, Dict, Any
from app.utils.logger import log_event
import json

def format_sources(contexts: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
    """Format sources for the final response"""
    sources = []
    
    for context in contexts:
        source = {
            "type": context["type"],
            "reference": context.get("reference", ""),
            "confidence": float(context.get("confidence", 0.5))
        }
        
        # Add additional metadata based on source type
        if context["type"] == "graph":
            source["reference"] = f"graph:{context.get('reference', '')}"
        elif context.get("source") == "semantic_search":
            source["type"] = "semantic"
        elif context["type"] == "news":
            source["category"] = "news"
        
        sources.append(source)
    
    # Remove duplicates and sort by confidence
    unique_sources = {}
    for source in sources:
        key = f"{source['type']}_{source['reference']}"
        if key not in unique_sources or source['confidence'] > unique_sources[key]['confidence']:
            unique_sources[key] = source
    
    sorted_sources = sorted(unique_sources.values(), key=lambda x: x["confidence"], reverse=True)
    return sorted_sources[:10]  # Limit to top 10 sources

def create_structured_output(answer: str, sources: List[Dict[str, Any]], reasoning: List[str] = None) -> Dict[str, Any]:
    """Create structured output for the response"""
    
    # Extract key points from the answer
    key_points = _extract_key_points(answer)
    
    # Create summary
    summary = _create_summary(answer, key_points)
    
    structured_output = {
        "key_points": key_points,
        "summary": summary,
        "source_count": len(sources),
        "reasoning_steps": len(reasoning) if reasoning else 0
    }
    
    # Add source breakdown
    source_types = {}
    for source in sources:
        source_type = source["type"]
        source_types[source_type] = source_types.get(source_type, 0) + 1
    
    structured_output["source_breakdown"] = source_types
    
    return structured_output

def _extract_key_points(answer: str, max_points: int = 5) -> List[str]:
    """Extract key points from the answer"""
    # Simple extraction - in production you might use more sophisticated NLP
    sentences = answer.split('. ')
    key_points = []
    
    for sentence in sentences:
        sentence = sentence.strip()
        if len(sentence) > 20 and len(sentence) < 150:  # Reasonable length
            if any(indicator in sentence.lower() for indicator in ['is a', 'includes', 'can be', 'used for', 'allows']):
                key_points.append(sentence)
        
        if len(key_points) >= max_points:
            break
    
    # Fallback if no good key points found
    if not key_points:
        key_points = [
            "Answer generated by AI reasoning agent",
            "Combined multiple information sources",
            "Structured for easy understanding"
        ]
    
    return key_points[:max_points]

def _create_summary(answer: str, key_points: List[str]) -> str:
    """Create a concise summary from the answer and key points"""
    if len(answer) <= 200:
        return answer
    
    # Use first sentence or create from key points
    first_sentence = answer.split('. ')[0]
    if len(first_sentence) > 50:
        return first_sentence + "..."
    else:
        return ". ".join(key_points[:2]) + "..."

def format_error_response(error_code: str, error_message: str) -> Dict[str, Any]:
    """Format standardized error responses"""
    error_map = {
        "AUTH_FAILED": {
            "code": "AUTH_FAILED",
            "message": "Invalid credentials provided.",
            "http_status": 401
        },
        "INVALID_REQUEST": {
            "code": "INVALID_REQUEST", 
            "message": "Request validation failed.",
            "http_status": 400
        },
        "PROCESSING_ERROR": {
            "code": "PROCESSING_ERROR",
            "message": "Error processing the query.",
            "http_status": 500
        },
        "INSUFFICIENT_CONTEXT": {
            "code": "INSUFFICIENT_CONTEXT",
            "message": "No relevant information found for the query.",
            "http_status": 404
        }
    }
    
    error_info = error_map.get(error_code, {
        "code": "UNKNOWN_ERROR",
        "message": "An unexpected error occurred.",
        "http_status": 500
    })
    
    return {
        "status": "error",
        "error": {
            "code": error_info["code"],
            "message": error_message or error_info["message"]
        }
    }